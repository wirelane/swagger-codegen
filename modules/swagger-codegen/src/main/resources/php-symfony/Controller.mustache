<?php
/**
 * Controller
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{controllerPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{controllerPackage}};

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\ConstraintViolation;
use {{servicePackage}}\SerializerInterface;
use {{servicePackage}}\ValidatorInterface;

/**
 * Controller Class Doc Comment
 *
 * @category Class
 * @package  {{controllerPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Controller
{
    /** @var \EMC\EmcApiBundle\Service\SymfonyValidator\SymfonyValidator */
    protected $validator;

    /** @var \Psr\Log\LoggerInterface\LoggerInterface */
    protected $logger;

    /** @var SerializerInterface */
    protected $serializer;

    protected $apiServer;

    protected $debugMode=false;
    protected $objectValidationLog = true;
    protected $objectValidationStrict = false;
    protected $binaryFormats=array(
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/pdf',
        'application/zip',
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/*'
    );

    public function setDebugMode($debugMode)
    {
        $this->debugMode = $debugMode;
    }

    public function setLogger(\Psr\Log\LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    public function setValidator(ValidatorInterface $validator)
    {
        $this->validator = $validator;
    }

    /**
     * @param bool $validateLog
     * @param bool $validateStrict
     */
    public function setObjectValidation($validateLog, $validateStrict)
    {
        $this->objectValidationLog = $validateLog;
        $this->objectValidationStrict = $validateStrict;
    }

    public function setSerializer(SerializerInterface $serializer)
    {
        $this->serializer = $serializer;
    }

    public function setApiServer($server)
    {
        $this->apiServer = $server;
    }

    /**
     * This will return a response with code 400. Usage example:
     *     return $this->createBadRequestResponse('Unable to access this page!');
     *
     * @param string $message A message
     *
     * @return Response
     */
    public function createBadRequestResponse($message = 'Bad Request.')
    {
        return new Response($message, 400);
    }

    /**
     * This will return an error response. Usage example:
     *     return $this->createErrorResponse(new UnauthorizedHttpException());
     *
     * @param HttpException $exception An HTTP exception
     *
     * @return Response
     */
    public function createErrorResponse(HttpException $exception)
    {
        $statusCode = $exception->getStatusCode();
        $headers    = array_merge($exception->getHeaders(), ['Content-Type' => 'application/json']);

        $json = $this->exceptionToArray($exception);
        $json['statusCode'] = $statusCode;

        return new Response(json_encode($json, 15, 512), $statusCode, $headers);
    }

    /**
     * Serializes data to a given type format.
     *
     * @param mixed  $data   The data to serialize.
     * @param string $class  The source data class.
     * @param string $format The target serialization format.
     *
     * @return string A serialized data string.
     */
    protected function serialize($data, $format)
    {
        if (in_array($format, $this->binaryFormats)) {
            return $data;
        }

        return $this->serializer->serialize($data, $format);
    }

    /**
     * Deserializes data from a given type format.
     *
     * @param string $data   The data to deserialize.
     * @param string $class  The target data class.
     * @param string $format The source serialization format.
     *
     * @return mixed A deserialized data.
     */
    protected function deserialize($data, $class, $format)
    {
        return $this->serializer->deserialize($data, $class, $format);
    }

    protected function validate($data, $asserts = null)
    {
        $errors = $this->validator->validate($data, $asserts);

        if (is_object($data) && ($this->objectValidationLog || $this->objectValidationStrict)) {
            $this->validateObject($data, $asserts, $errors);
        }

        if (count($errors) > 0) {
            $errorsString = (string)$errors;
            return $this->createBadRequestResponse($errorsString);
        }
    }

    /**
     * If this is a typed object (it has an own model, therefore a Assert\Type-Constraint),
     * we explicitly validate it.
     * If objectValidationStrict is enabled, then validation errors will be added to the regular list of validation errors.
     * If objectValidationLog is enabled, then messages will be written to the log.
     *
     * @param object $object
     * @param \Symfony\Component\Validator\Constraint[]|null $asserts
     * @param \Symfony\Component\Validator\ConstraintViolationList $validationErrors
     */
    protected function validateObject($object, $asserts, $validationErrors)
    {
        if (!is_array($asserts) || count(array_filter($asserts, function ($assert) {
            return is_object($assert) && is_a($assert, \Symfony\Component\Validator\Constraints\Type::class);
        })) === 0) {
            return;
        }
        /** @var \Symfony\Component\Validator\ConstraintViolationList $result */
        $result = $this->validator->validate($object);
        if ($result->count() > 0) {
            if ($this->objectValidationStrict) {
                $validationErrors->addAll($result);
            }
            if ($this->objectValidationLog) {
                $this->logger->info('OpenAPI object input validation error', [
                    'errors' => array_map(function (ConstraintViolation $violation) {
                        return [
                            'class' => (is_object($violation->getRoot()) ? get_class($violation->getRoot()) : null),
                            'property' => $violation->getPropertyPath(),
                            'message' => $violation->getMessage(),
                            'value' => $violation->getInvalidValue(),
                        ];
                    }, $result->getIterator()->getArrayCopy()),
                    'full_object' => $this->serializer->serialize($object, 'application/json'),
                ]);
            }
        }
    }

    /**
     * Converts an exception to a serializable array.
     *
     * @param \Exception|null $exception
     *
     * @return array
     */
    private function exceptionToArray(\Exception $exception = null)
    {
        if (null === $exception) {
            return null;
        }

        if (!$this->debugMode) {
            return [
                'message'  => $exception->getMessage(),
            ];
        }

        return [
            'message'  => $exception->getMessage(),
            'type'     => get_class($exception),
            'file'     => $exception->getFile(),
            'line'     => $exception->getLine(),
            'previous' => $this->exceptionToArray($exception->getPrevious()),
        ];
    }

    protected function getOutputFormat($accept, array $produced)
    {
        // Figure out what the client accepts
        $accept = preg_split("/[\s,]+/", $accept);
        
        if (in_array('*/*', $accept) || in_array('application/*', $accept)) {
            // Prefer JSON if the client has no preference
            if (in_array('application/json', $produced)) {
                return 'application/json';
            }
            if (in_array('application/xml', $produced)) {
                return 'application/xml';
            }
        }

        if (in_array('application/json', $accept) && in_array('application/json', $produced)) {
            return 'application/json';
        }

        if (in_array('application/xml', $accept) && in_array('application/xml', $produced)) {
            return 'application/xml';
        }

        //Binary formats
        foreach($this->binaryFormats as $binaryFormat){
            if (in_array($binaryFormat, $accept) && in_array($binaryFormat, $produced)) {
                return $binaryFormat;
            }
        }

        // If we reach this point, we don't have a common ground between server and client
        return null;
    }
}
